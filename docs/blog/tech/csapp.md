# CSAPP阅读

## 参考资料

[读薄csapp博客](https://wdxtub.com/csapp/thin-csapp-0/2016/04/16/)
[csapp gitbook电子书](https://hansimov.gitbook.io/csapp/)


[csapp 英文原版pdf](https://github.com/wangmu89/Book-CSAPP/blob/master/_Attachments/Computer_Systems_A_Programmers_Perspective(3rd).pdf)
[编程书籍汇总](https://github.com/imarvinle/awesome-cs-books#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F)

## 学习检查点
> 本环节可以理解成大学学习中的作业， 目的是为了让学习真正产生效果。 作业会从讨论和博客，实验两个角度入手， 考察理解和实践的能力。 每个项目的checkList由大家补充投票定义， 靠自觉完成。


书本阅读讨论和博客，大概每周一篇
TODO

实验
TODO


## 个人笔记
> 说明:本文就是阅读[《读薄csapp》](https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/)系列博客的再抽象、理解记录。适合

### 第一章
#### 学习目标

1. 理解计算机系统的复杂与和理论抽象描述的不同
1. 理解内存中数据的保存形式，以及这种方式的好处以及限制
1. 注意避开一些常见的关于计算机的迷思
1. 区别整型和浮点数的表达机制，并理解为什么会有这种差异
1. 简单理解溢出出现的条件

**计算机不只是执行程序的机器**
> 现代计算机的冯诺依曼的结构

**很多东西不像看起来那么简单**
> 1. 时空复杂度， 在多线程甚至分布式并行计算的条件下， 需要特别考虑，比如是否能拆分并行运算， 是否会线程安全。
> 2. 计算机的数学运算存在溢出和精度问题
> 3. 很多算法，思想的设计， 往往都很难最优， 而是在限制下比较好的一种**权衡**，比如时间换空间，锁机制。


**内存里多的是我们不知道的事**
> 1. 内存问题在实践中特别容易发生，排查起来也非常困难（典型的是内存泄漏、野指针、悬垂指针，多线程问题）

#### 比特心生

计算机的任何指令、数据都是二进制表示的。而现实生活中的数字往往是10进制表示的。而为了让2进制读起来更快、写起来更少、记起来也不会太多， 2进制4位为一组，生成了16进制。
也就是说我们需要背一下16进制。但实际上，16进制基本上和10进制类似， 所以2进制到16进制的转换一般经过10进制。
比如1-9 -> 1-9, 10-15 -> A-F

而二进制的4位， 为了更好算有一点， 我们拆成2组，前2位一组，后2位1组。
比如$1011=10<<2+11=10*2+1=4*2+3=8+3=11$

这样拆分的好处就是，我们只需要背下三位二进制的映射就行了。也就是


|2机制b|10进制d|16进制h|
|-|-|-|
|1001|4*2+1=9|9
|1010|5*2+0=10|A
|1011|5*2+1=11|B
|1100|6*2+0-12|C
|1101|6*2+1=13|D
|1110|7*2+1=14|E
|1111|15=15|F
而对于10进制与16进制的转换，我们只要管A-F 与 10-15的转换。好在我们从小写选择题以及让我们建立了A-E -> 1-5 -> 1+9-4+9 -> 10-14的映射。 最后剩下个F，就是1111就是15啊，多好记。（/wink)

#### 整数
**整型表示的特点**

我们知道对于计算机里的二进制，有符号数和无符号数改变的只是该部分内存的类型，而不改变吗值本身。

所以为了让相同位数w的无符号（$0\to2^w-1)$和有符号数能够比较容易地对应上，
我们直接让一半数$0 \to 2^{w-1}-1$的解释不变，
剩下的一半数$2^{w-1}\to2^w-1$， 让他直接往回调一圈(即$-2^w$)，变成$-2^{w-1}\to-1$

这样做的好处有
1. 小的数在有符号和无符号的数在$0 \to 2^{w-1}-1$上完全一致
2. 无符号数越小，对应的有符号数的负数也越小。
3. 有符号数的负数$x\%2^{w} == x+2^{w}$

![](https://wdxtub.com/images/csapp/14609257940557.jpg)

**C语言中signed和unsigned的比较**

2个原则
1. C语言中常量默认是有符号数, 除非显式加上`U`后缀
2. 有符号和无符号数做运算时，会都当做无符号数做比较比如$-1<0, -1>0U$


**截取和拓展**

位多的数往位低的数转换时，需要截取保留低位， 相反需要拓展高位。
截取和拓展其实从十进制看来是很直觉的，即向下兼容。
- 对于拓展，其实就是10进制保持不变（也即正数给补0， 负数给补1)
- 对于截取，不区分正负数直接截取l(比如下面代码的结果)
```c++
#include <cstdio>
int main() {
    int a = 0x7fffffff;
    short b = (short)a;
    int c = 0xffffffff;
    short d = (short)c;
    int e = 0xffff7fff;
    short f = (short)e;
    printf("%d->%d, %d->%d, %d->%d", a,b,c,d,e,f);
    return 0;
}
//2147483647->-1, -1->-1, -32769->32767
```

#### 浮点数
浮点数这个名字起得很不错，其实就是在整数的<u>**位中间加了个点**</u>。
点左边的叫整数部分，右边的叫小数部分。
也可以看成是一个整数，除上了$2^{t} (t是小数的位数)$

**IEEE 浮点数标准**
$value=(-1)^{s}M2^{E}$
![](https://wdxtub.com/images/csapp/14609515849125.jpg)
$E_{10}=exp_{2}, M=1+frac_2(frac表示的小数是0.x...., x\not ={0})$
其中exp是一个有符号数E的移码。

**浮点数的无穷和0**

**舍入**

**浮点数加法**

**浮点数乘法**

#### 数据在内存中的形式


